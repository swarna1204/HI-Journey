<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hyper Island Journey ‚Äì Three.js WebXR Interaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #storyOverlay {
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            pointer-events: none;
            z-index: 1;
        }

        #enterVR {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>

<body>
    <div id="storyOverlay"></div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/webxr/VRButton.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/webxr/XRControllerModelFactory.js"></script>
    <script>
        let camera, scene, renderer;
        let controller1, controller2;
        let raycaster = new THREE.Raycaster();
        let tempMatrix = new THREE.Matrix4();
        let model; // your GLB scene

        const overlay = document.getElementById('storyOverlay');

        init();
        animate();

        function init() {
            // Scene + Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222831);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 3);

            // Lights
            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Renderer + WebXR
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Load GLB model
            new THREE.GLTFLoader().load('model/model.glb', gltf => {
                model = gltf.scene;
                scene.add(model);
            });

            // Controllers
            const controllerModelFactory = new THREE.XRControllerModelFactory();

            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('select', onSelect);
            scene.add(controller1);

            const grip1 = renderer.xr.getControllerGrip(0);
            grip1.add(controllerModelFactory.createControllerModel(grip1));
            scene.add(grip1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('select', onSelect);
            scene.add(controller2);

            const grip2 = renderer.xr.getControllerGrip(1);
            grip2.add(controllerModelFactory.createControllerModel(grip2));
            scene.add(grip2);

            window.addEventListener('resize', onWindowResize);
        }

        function onSelect(event) {
            // Raycast from controller
            const controller = event.target;
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            if (!model) return;
            const intersects = raycaster.intersectObject(model, true);
            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const name = hit.name || hit.parent.name || 'unknown';
                console.log('Controller hit mesh:', name);
                showStory(name);
                focusCameraOn(hit);
            }
        }

        function showStory(meshName) {
            let html;
            const l = meshName.toLowerCase();
            if (l.includes('bed')) {
                html = 'üõèÔ∏è <b>The Bed</b><br>Balancing motherhood and ambition‚Ä¶';
            } else if (l.includes('monitor')) {
                html = 'üíª <b>The Monitor</b><br>Countless late-night coding sessions‚Ä¶';
            } else if (l.includes('plant')) {
                html = 'ü™¥ <b>The Plant</b><br>Roots take time to grow.';
            } else {
                html = '‚ú® <b>Discovery</b><br>Every object holds a story.';
            }
            overlay.innerHTML = html;
            overlay.style.display = 'block';
            setTimeout(() => overlay.style.display = 'none', 3000);
        }

        function focusCameraOn(mesh) {
            // Simple camera tween toward mesh center
            const bbox = new THREE.Box3().setFromObject(mesh);
            const center = bbox.getCenter(new THREE.Vector3());
            const newPos = center.clone().add(new THREE.Vector3(0, 1.5, 2));

            new TWEEN.Tween(camera.position)
                .to({ x: newPos.x, y: newPos.y, z: newPos.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            const dir = center.clone().sub(camera.position).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(
                new THREE.Vector3(0, 0, -1), dir
            );
            new TWEEN.Tween(camera.quaternion)
                .to({ x: targetQuat.x, y: targetQuat.y, z: targetQuat.z, w: targetQuat.w }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            TWEEN.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>