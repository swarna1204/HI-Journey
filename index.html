<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>VR Clickable Meshes ‚Äî A-Frame</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #storyOverlay {
            display: none;
            position: fixed;
            left: 50%;
            top: 110px;
            transform: translateX(-50%);
            background: rgba(34, 40, 49, 0.95);
            color: #fff;
            font-size: 1.5rem;
            max-width: 80vw;
            padding: 1.3rem 2.3rem;
            border-radius: 18px;
            box-shadow: 0 4px 32px #111a;
            z-index: 99999 !important;
            text-align: center;
            letter-spacing: 0.03em;
            pointer-events: none;
        }

        #buttons {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
            flex-wrap: wrap;
            pointer-events: auto;
        }

        .zoomButton {
            background: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            color: #222831;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            opacity: 0.5;
            pointer-events: auto;
        }

        .zoomButton.enabled {
            opacity: 1;
            pointer-events: auto;
        }

        #backButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            display: none;
            pointer-events: auto;
        }
    </style>
    <script>
        // Create proxy entities for each named mesh in the model for raycaster targetting.
        AFRAME.registerComponent('make-mesh-clickable', {
            schema: {
                selectors: {
                    type: 'array', default: [
                        "monitor", "bed", "houseplant", "rack", "cylinder", "speaker", "cube"
                    ]
                }
            },
            init: function () {
                this.el.addEventListener('model-loaded', e => {
                    const model = this.el.getObject3D('mesh');
                    if (!model) return;
                    // Get mesh proxies parent (so can be easily cleared/recreated)
                    let proxiesParent = document.querySelector('#mesh-proxies');
                    if (proxiesParent) proxiesParent.parentNode.removeChild(proxiesParent);
                    proxiesParent = document.createElement('a-entity');
                    proxiesParent.setAttribute('id', 'mesh-proxies');
                    this.el.sceneEl.appendChild(proxiesParent);

                    // For each mesh, create a box entity for VR clicking
                    model.traverse(node => {
                        if (node.isMesh) {
                            // Try to match mesh names to selectors for clickability
                            let match = false;
                            const nameLower = node.name.toLowerCase();
                            for (let sel of this.data.selectors) {
                                if (nameLower.includes(sel)) { match = sel; break; }
                            }
                            if (!match) return;
                            // Get bounding box for mesh
                            const box = new THREE.Box3().setFromObject(node);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            // Add invisible clickable box
                            const proxy = document.createElement('a-box');
                            proxy.setAttribute('class', 'clickable');
                            proxy.setAttribute('position', `${center.x} ${center.y} ${center.z}`);
                            proxy.setAttribute('width', Math.max(size.x * 1.12, 0.01));
                            proxy.setAttribute('height', Math.max(size.y * 1.12, 0.01));
                            proxy.setAttribute('depth', Math.max(size.z * 1.12, 0.01));
                            proxy.setAttribute('opacity', 0.0); // Invisible but clickable
                            proxy.setAttribute('meshname', node.name); // store mesh name
                            proxy.setAttribute('hoverable', ''); // optional for highlight
                            proxy.setAttribute('event-set__enter', '_event: mouseenter; opacity: 0.08');
                            proxy.setAttribute('event-set__leave', '_event: mouseleave; opacity: 0.0');
                            proxiesParent.appendChild(proxy);
                        }
                    });
                });
            }
        });
    </script>
</head>

<body>
    <div id="buttons">
        <div class="zoomButton" data-target="monitor">Monitor</div>
        <div class="zoomButton" data-target="bed">Bed</div>
        <div class="zoomButton" data-target="houseplant">Plant</div>
        <div class="zoomButton" data-target="rack">YT Frame</div>
        <div class="zoomButton" data-target="cylinder">Wall Frame</div>
        <div class="zoomButton" data-target="speaker">Speaker</div>
        <div class="zoomButton" data-target="cube">Light</div>
    </div>
    <div id="backButton">Back</div>
    <div id="storyOverlay"></div>
    <audio id="bg-music" src="music/believe-emotional-beautiful-peaceful-hopeful-piano-with-orchestra-219416.mp3"
        loop></audio>

    <a-scene id="scene" xr-mode-ui="enabled: true" cursor="rayOrigin: mouse" raycaster="objects: .clickable"
        renderer="antialias: true; precision: high;">
        <a-sky color="#222831"></a-sky>
        <a-entity light="type: ambient; intensity: 1"></a-entity>
        <a-entity light="type: directional; intensity: 0.8" position="5 10 5"></a-entity>
        <a-assets>
            <a-asset-item id="roomModel" src="model/model.glb"></a-asset-item>
        </a-assets>
        <a-entity id="model" gltf-model="#roomModel" position="-5 -10 -5" scale="10 10 10"
            make-mesh-clickable></a-entity>
        <a-entity id="cameraRig" position="0 4 10">
            <a-camera look-controls wasd-controls></a-camera>
            <!-- Only right hand raycaster for VR -->
            <a-entity laser-controls="hand: right" raycaster="objects: .clickable"></a-entity>
        </a-entity>
    </a-scene>
    <script>
        window.addEventListener('click', function enableAudio() {
            var audio = document.getElementById('bg-music');
            if (audio && audio.paused) {
                audio.play();
                window.removeEventListener('click', enableAudio);
            }
        });

        const sceneEl = document.querySelector('a-scene');
        const cameraEl = document.querySelector('#cameraRig');
        const zoomButtons = document.querySelectorAll('.zoomButton');
        const backButton = document.getElementById('backButton');
        const storyOverlay = document.getElementById('storyOverlay');
        let clickableObjects = {};

        const defaultCameraPos = new THREE.Vector3(0, 4, 10);
        const defaultCameraQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));

        const zoomDistances = {
            'speaker': 3,
            'cube': 4,
            'default': 3.5
        };

        function showStory(text) {
            storyOverlay.innerHTML = text;
            storyOverlay.style.display = "block";
        }
        function hideStory() {
            storyOverlay.style.display = "none";
        }
        function showStoryForMesh(meshName) {
            if (!meshName) return;
            const lower = meshName.toLowerCase();
            if (lower.includes("bed") || lower.includes("blanket") || lower.includes("pillow")) {
                showStory("üõèÔ∏è <b>The Bed</b><br>Balancing motherhood and ambition‚Äîmy journey was about family as much as career.");
            } else if (lower.includes("monitor")) {
                showStory("üíª <b>The Monitor</b><br>Countless late nights learning, coding, and applying for jobs. Every click was a step forward.");
            } else if (lower.includes("plant")) {
                showStory("ü™¥ <b>The Plant</b><br>Roots take time. I was growing quietly in a new city, finding my place.");
            } else if (lower.includes("rack")) {
                showStory("üé¨ <b>The YouTube Frame</b><br>YouTube was my classroom and my comfort‚Äîwhere I learned to code, drew inspiration from creators, and found motivation in stories beyond the screen.");
            } else if (lower.includes("cylinder")) {
                showStory("üñºÔ∏è <b>The Wall Frame</b><br>My wall frames capture moments of growth, lessons learned, obstacles faced, and milestones achieved‚Äîa daily reminder to pursue my dreams.");
            } else if (lower.includes("speaker")) {
                showStory("üîä <b>The Speaker</b><br>Podcasts and music kept me company, fueling resilience and hope.");
            } else if (lower.includes("cube")) {
                showStory("üí° <b>The Light</b><br>The light shines on my journey‚Äîfilled with vision, hope, and new direction. At Hyper Island, I grew into a front-end developer. Now, I dream of taking my roots and wings to a product based company, blending UI/UX design with development and letting my ambitions soar.");
            } else {
                showStory("‚ú® <b>Something in My Room</b><br>This object is part of the story, but not a main scene highlight. Explore more!");
            }
        }
        function focusOnObject(meshName) {
            // Wait until model has loaded and proxies created
            const camera3D = cameraEl.object3D;
            const meshProxy = document.querySelector(`a-box[meshname='${meshName}']`);
            if (!meshProxy) {
                alert("Object not found: " + meshName);
                return;
            }
            const pos = meshProxy.object3D.getWorldPosition(new THREE.Vector3());
            let newCameraPos, lookAtTarget;
            const lower = meshName.toLowerCase();
            if (lower.includes('cylinder')) {
                newCameraPos = pos.clone().add(new THREE.Vector3(0, 0, 5));
                lookAtTarget = pos.clone();
            }
            else if (lower.includes('bed')) {
                newCameraPos = pos.clone().add(new THREE.Vector3(0, 8, 0));
                lookAtTarget = pos.clone();
            }
            else if (lower.includes('cube')) {
                newCameraPos = pos.clone().add(new THREE.Vector3(0, 0, 4));
                lookAtTarget = pos.clone();
            }
            else {
                const direction = pos.clone().sub(camera3D.position).normalize();
                const zoomDistance = zoomDistances[meshName.toLowerCase()] || zoomDistances['default'];
                newCameraPos = pos.clone().add(direction.multiplyScalar(-zoomDistance));
                lookAtTarget = pos.clone();
            }
            new TWEEN.Tween(camera3D.position)
                .to({ x: newCameraPos.x, y: newCameraPos.y, z: newCameraPos.z }, 1200)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
            const temp = { t: 0 };
            const startQuat = camera3D.quaternion.clone();
            const endQuat = new THREE.Quaternion().setFromRotationMatrix(
                new THREE.Matrix4().lookAt(newCameraPos, lookAtTarget, new THREE.Vector3(0, 1, 0))
            );
            new TWEEN.Tween(temp)
                .to({ t: 1 }, 1200)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    camera3D.quaternion.copy(startQuat).slerp(endQuat, temp.t);
                })
                .start();
            backButton.style.display = "block";
        }
        // Enable desktop zoom buttons only after proxies ready
        sceneEl.addEventListener('loaded', () => {
            setTimeout(() => {
                zoomButtons.forEach(b => b.classList.add('enabled'));
                showStory("üå± <b>A New City, A New Start</b><br><span style='font-size:1rem;opacity:0.82'>My Hyper Island journey began here, where everything felt new and full of hope.</span>");
            }, 1200);
        });
        zoomButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (!button.classList.contains('enabled')) return;
                const meshName = button.dataset.target;
                focusOnObject(meshName);
                showStoryForMesh(meshName);
            });
        });

        // Listen for VR/desktop clicks on the invisible proxy entities
        sceneEl.addEventListener('click', function (evt) {
            let meshName;
            // VR: clicking proxy box
            if (evt.target && evt.target.hasAttribute && evt.target.hasAttribute('meshname')) {
                meshName = evt.target.getAttribute('meshname');
            }
            // Desktop fallback: mouse pick via raycaster
            else if (evt.target && evt.target === sceneEl) {
                const intersection = sceneEl.components.raycaster.getIntersection(document.querySelector('#model'));
                if (intersection && intersection.object && intersection.object.name) {
                    meshName = intersection.object.name;
                }
            }
            if (meshName) {
                focusOnObject(meshName);
                showStoryForMesh(meshName);
            }
        });

        backButton.addEventListener('click', () => {
            const camera3D = cameraEl.object3D;
            new TWEEN.Tween(camera3D.position)
                .to({ x: defaultCameraPos.x, y: defaultCameraPos.y, z: defaultCameraPos.z }, 1200)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
            const temp = { t: 0 };
            const startQuat = camera3D.quaternion.clone();
            const endQuat = defaultCameraQuat.clone();
            new TWEEN.Tween(temp)
                .to({ t: 1 }, 1200)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    camera3D.quaternion.copy(startQuat).slerp(endQuat, temp.t);
                })
                .start();
            backButton.style.display = "none";
            hideStory();
        });
        function animate() { requestAnimationFrame(animate); TWEEN.update(); }
        animate();
    </script>
</body>

</html>